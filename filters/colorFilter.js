// filters/colorFilter.js

import { getStellarClassData } from './stellarClassData.js';
import { generateConstellationColors } from '../utils.js';

/**
 * Applies the selected color filter to the star objects.
 * Supported filters:
 *   - "stellar-class": Colors are taken from stellar_class.json.
 *   - "constellation": Colors are generated per constellation.
 *   - "galactic-plane": Colors based on distance from the galactic plane.
 *   - (default): Fallback to white.
 *
 * @param {Array} stars - The array of star objects.
 * @param {Object} filters - The current filters settings.
 * @returns {Array} - The updated star objects.
 */
export function applyColorFilter(stars, filters) {
  const stellarClassData = getStellarClassData();

  if (filters.color === 'stellar-class') {
    // Use the stellar class data
    stars.forEach(star => {
      let pClass = 'G';
      if (star.Stellar_class && typeof star.Stellar_class === 'string') {
        pClass = star.Stellar_class.charAt(0).toUpperCase();
      }
      const cData = stellarClassData[pClass];
      // Use the color from data or fallback to white.
      let colorValue = cData ? cData.color : '#FFFFFF';
      // Convert numeric colors or strings missing '#' into proper CSS strings.
      colorValue = normalizeColor(colorValue);
      star.displayColor = colorValue;
    });

  } else if (filters.color === 'constellation') {
    // Colors generated by constellation
    const colorsMap = generateConstellationColors(stars);
    stars.forEach(star => {
      let colorValue = colorsMap[star.Constellation] || '#FFFFFF';
      colorValue = normalizeColor(colorValue);
      star.displayColor = colorValue;
    });

  } else if (filters.color === 'galactic-plane') {
    // Colors based on distance from the galactic plane.
    const maxZ = Math.max(...stars.map(s => Math.abs(s.z_coordinate)));
    stars.forEach(star => {
      const factor = Math.abs(star.z_coordinate) / maxZ;
      if (star.z_coordinate < 0) {
        star.displayColor = interpolateHex('#ffffff', '#0000ff', factor);
      } else if (star.z_coordinate > 0) {
        star.displayColor = interpolateHex('#ffffff', '#ff0000', factor);
      } else {
        star.displayColor = '#ffffff';
      }
    });

  } else {
    // Fallback: ensure every star has a color.
    stars.forEach(star => {
      if (!star.displayColor) {
        star.displayColor = '#FFFFFF';
      }
    });
  }
  return stars;
}

/**
 * Normalizes a color value into a proper CSS hex string.
 * If the input is a number (e.g. 0xff9933), it converts it.
 * If the input is a string without a leading '#', it adds one.
 *
 * @param {string|number} colorValue
 * @returns {string} - A CSS hex string (e.g. "#ff9933").
 */
function normalizeColor(colorValue) {
  if (typeof colorValue === 'number') {
    // Convert number to hex string and ensure 6 digits.
    return '#' + colorValue.toString(16).padStart(6, '0');
  }
  if (typeof colorValue === 'string') {
    // Trim any whitespace.
    colorValue = colorValue.trim();
    if (colorValue[0] !== '#') {
      return '#' + colorValue;
    }
    return colorValue;
  }
  // Fallback to white.
  return '#FFFFFF';
}

/**
 * Interpolates between two hex colors.
 * @param {string} hex1 - The starting hex color (e.g. "#ffffff").
 * @param {string} hex2 - The ending hex color (e.g. "#ff0000").
 * @param {number} factor - Interpolation factor in [0,1].
 * @returns {string} - The interpolated hex color.
 */
function interpolateHex(hex1, hex2, factor) {
  const c1 = hexToRgb(hex1);
  const c2 = hexToRgb(hex2);
  const r = Math.round(c1.r + factor * (c2.r - c1.r));
  const g = Math.round(c1.g + factor * (c2.g - c1.g));
  const b = Math.round(c1.b + factor * (c2.b - c1.b));
  return rgbToHex(r, g, b);
}

/**
 * Converts a hex color string to an object with r, g, b.
 * @param {string} hex - A hex color string (e.g. "#ff00ff").
 * @returns {Object} - { r, g, b }
 */
function hexToRgb(hex) {
  const normalized = hex.replace('#', '');
  const bigint = parseInt(normalized, 16);
  const r = (bigint >> 16) & 255;
  const g = (bigint >> 8) & 255;
  const b = bigint & 255;
  return { r, g, b };
}

/**
 * Converts r, g, b values to a hex color string.
 * @param {number} r - Red (0–255).
 * @param {number} g - Green (0–255).
 * @param {number} b - Blue (0–255).
 * @returns {string} - A hex color string (e.g. "#ff00ff").
 */
function rgbToHex(r, g, b) {
  const componentToHex = c => c.toString(16).padStart(2, '0');
  return '#' + componentToHex(r) + componentToHex(g) + componentToHex(b);
}
